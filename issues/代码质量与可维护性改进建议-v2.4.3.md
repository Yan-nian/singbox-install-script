# 代码质量与可维护性改进建议

## 版本信息
- **版本**: v2.4.3
- **日期**: 2024年
- **范围**: 核心功能优化（排除WARP、Argo、Tuic功能）

## 1. 架构优化建议

### 1.1 配置管理中心化
**当前问题**: 配置分散在多个文件中，缺乏统一管理

**改进方案**:
```bash
# 创建统一配置管理器
class ConfigManager {
    private config_file="/etc/singbox/config.json"
    private backup_dir="/etc/singbox/backups"
    
    load_config() {
        # 统一配置加载逻辑
    }
    
    save_config() {
        # 统一配置保存逻辑
        # 自动备份机制
    }
    
    validate_config() {
        # 配置验证逻辑
    }
}
```

### 1.2 错误处理标准化
**当前问题**: 错误处理不一致，缺乏统一的错误码体系

**改进方案**:
```bash
# lib/error_handler.sh
declare -A ERROR_CODES=(
    ["CONFIG_NOT_FOUND"]=1001
    ["PORT_OCCUPIED"]=1002
    ["CERT_INVALID"]=1003
    ["SERVICE_FAILED"]=1004
)

handle_error() {
    local error_code=$1
    local error_msg=$2
    local context=$3
    
    log_error "[${error_code}] ${error_msg} - Context: ${context}"
    
    case $error_code in
        ${ERROR_CODES["CONFIG_NOT_FOUND"]})
            suggest_config_recovery
            ;;
        ${ERROR_CODES["PORT_OCCUPIED"]})
            suggest_port_alternatives
            ;;
    esac
    
    exit $error_code
}
```

## 2. 代码质量提升

### 2.1 函数设计原则
**单一职责原则**:
```bash
# 当前: 一个函数做多件事
configure_protocol() {
    generate_uuid
    set_port
    create_config
    start_service
    show_result
}

# 改进: 拆分为单一职责函数
generate_protocol_uuid() { ... }
select_protocol_port() { ... }
create_protocol_config() { ... }
start_protocol_service() { ... }
display_protocol_info() { ... }

configure_protocol() {
    local uuid=$(generate_protocol_uuid)
    local port=$(select_protocol_port)
    create_protocol_config "$uuid" "$port"
    start_protocol_service
    display_protocol_info "$uuid" "$port"
}
```

### 2.2 参数验证增强
```bash
validate_port() {
    local port=$1
    
    # 参数存在性检查
    [[ -z "$port" ]] && handle_error ${ERROR_CODES["INVALID_PARAM"]} "端口参数为空"
    
    # 数值范围检查
    [[ ! "$port" =~ ^[0-9]+$ ]] && handle_error ${ERROR_CODES["INVALID_PARAM"]} "端口必须为数字"
    [[ $port -lt 1 || $port -gt 65535 ]] && handle_error ${ERROR_CODES["INVALID_PARAM"]} "端口范围无效"
    
    # 端口占用检查
    if netstat -tuln | grep -q ":$port "; then
        handle_error ${ERROR_CODES["PORT_OCCUPIED"]} "端口 $port 已被占用"
    fi
    
    return 0
}
```

### 2.3 日志系统完善
```bash
# lib/logger.sh
LOG_LEVEL=${LOG_LEVEL:-"INFO"}
LOG_FILE="/var/log/singbox/install.log"

log_with_level() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 控制台输出（带颜色）
    case $level in
        "ERROR") echo -e "\033[31m[$timestamp] [$level] $message\033[0m" ;;
        "WARN")  echo -e "\033[33m[$timestamp] [$level] $message\033[0m" ;;
        "INFO")  echo -e "\033[32m[$timestamp] [$level] $message\033[0m" ;;
        "DEBUG") [[ $LOG_LEVEL == "DEBUG" ]] && echo -e "\033[36m[$timestamp] [$level] $message\033[0m" ;;
    esac
    
    # 文件输出
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
}

log_error() { log_with_level "ERROR" "$1"; }
log_warn()  { log_with_level "WARN" "$1"; }
log_info()  { log_with_level "INFO" "$1"; }
log_debug() { log_with_level "DEBUG" "$1"; }
```

## 3. 性能优化

### 3.1 配置加载优化
```bash
# 当前: 每次都重新解析JSON
get_config_value() {
    local key=$1
    jq -r ".$key" /etc/singbox/config.json
}

# 改进: 缓存机制
declare -A CONFIG_CACHE
CACHE_TIMESTAMP=0

load_config_cache() {
    local config_file="/etc/singbox/config.json"
    local current_timestamp=$(stat -c %Y "$config_file" 2>/dev/null || echo 0)
    
    if [[ $current_timestamp -gt $CACHE_TIMESTAMP ]]; then
        log_debug "重新加载配置缓存"
        
        # 清空旧缓存
        unset CONFIG_CACHE
        declare -gA CONFIG_CACHE
        
        # 加载新配置
        while IFS='=' read -r key value; do
            CONFIG_CACHE["$key"]="$value"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$config_file")
        
        CACHE_TIMESTAMP=$current_timestamp
    fi
}

get_config_value() {
    local key=$1
    load_config_cache
    echo "${CONFIG_CACHE[$key]}"
}
```

### 3.2 并发处理优化
```bash
# 端口检测并发化
check_ports_concurrent() {
    local ports=("$@")
    local pids=()
    local results_dir="/tmp/port_check_$$"
    
    mkdir -p "$results_dir"
    
    # 并发检测
    for port in "${ports[@]}"; do
        {
            if netstat -tuln | grep -q ":$port "; then
                echo "occupied" > "$results_dir/$port"
            else
                echo "free" > "$results_dir/$port"
            fi
        } &
        pids+=("$!")
    done
    
    # 等待所有检测完成
    for pid in "${pids[@]}"; do
        wait "$pid"
    done
    
    # 收集结果
    local occupied_ports=()
    for port in "${ports[@]}"; do
        if [[ $(cat "$results_dir/$port") == "occupied" ]]; then
            occupied_ports+=("$port")
        fi
    done
    
    rm -rf "$results_dir"
    
    if [[ ${#occupied_ports[@]} -gt 0 ]]; then
        log_error "以下端口已被占用: ${occupied_ports[*]}"
        return 1
    fi
    
    return 0
}
```

## 4. 可维护性增强

### 4.1 配置模板系统
```bash
# templates/protocol_template.json
{
    "template_version": "1.0",
    "protocols": {
        "vless": {
            "type": "vless",
            "listen": "::",
            "listen_port": "{{PORT}}",
            "users": [{
                "uuid": "{{UUID}}",
                "flow": "xtls-rprx-vision"
            }],
            "tls": {
                "enabled": true,
                "server_name": "{{SERVER_NAME}}",
                "reality": {
                    "enabled": true,
                    "handshake": {
                        "server": "{{REALITY_SERVER}}",
                        "server_port": 443
                    },
                    "private_key": "{{PRIVATE_KEY}}",
                    "short_id": ["{{SHORT_ID}}"]
                }
            }
        }
    }
}

# 模板渲染函数
render_template() {
    local template_file=$1
    local output_file=$2
    shift 2
    local variables=("$@")
    
    local content=$(cat "$template_file")
    
    # 替换变量
    for var in "${variables[@]}"; do
        local key=${var%%=*}
        local value=${var#*=}
        content=${content//"{{$key}}"/"$value"}
    done
    
    echo "$content" > "$output_file"
}
```

### 4.2 自动化测试框架
```bash
# tests/test_framework.sh
TEST_COUNT=0
TEST_PASSED=0
TEST_FAILED=0

assert_equals() {
    local expected=$1
    local actual=$2
    local test_name=$3
    
    ((TEST_COUNT++))
    
    if [[ "$expected" == "$actual" ]]; then
        ((TEST_PASSED++))
        log_info "✓ $test_name"
    else
        ((TEST_FAILED++))
        log_error "✗ $test_name - Expected: '$expected', Actual: '$actual'"
    fi
}

assert_file_exists() {
    local file_path=$1
    local test_name=$2
    
    ((TEST_COUNT++))
    
    if [[ -f "$file_path" ]]; then
        ((TEST_PASSED++))
        log_info "✓ $test_name"
    else
        ((TEST_FAILED++))
        log_error "✗ $test_name - File not found: $file_path"
    fi
}

run_test_suite() {
    local test_dir=$1
    
    log_info "开始运行测试套件: $test_dir"
    
    for test_file in "$test_dir"/*.sh; do
        [[ -f "$test_file" ]] || continue
        log_info "运行测试文件: $(basename "$test_file")"
        source "$test_file"
    done
    
    log_info "测试完成 - 总计: $TEST_COUNT, 通过: $TEST_PASSED, 失败: $TEST_FAILED"
    
    if [[ $TEST_FAILED -gt 0 ]]; then
        return 1
    fi
    
    return 0
}
```

### 4.3 版本管理改进
```bash
# lib/version_manager.sh
VERSION_FILE="/etc/singbox/version.json"

get_current_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        jq -r '.version' "$VERSION_FILE"
    else
        echo "unknown"
    fi
}

update_version() {
    local new_version=$1
    local changes=$2
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    local version_info=$(jq -n \
        --arg version "$new_version" \
        --arg timestamp "$timestamp" \
        --arg changes "$changes" \
        '{
            version: $version,
            updated_at: $timestamp,
            changes: $changes,
            previous_version: null
        }')
    
    # 保存当前版本为previous_version
    if [[ -f "$VERSION_FILE" ]]; then
        local current_version=$(get_current_version)
        version_info=$(echo "$version_info" | jq --arg prev "$current_version" '.previous_version = $prev')
    fi
    
    echo "$version_info" > "$VERSION_FILE"
    log_info "版本已更新至: $new_version"
}
```

## 5. 安全性增强

### 5.1 输入验证强化
```bash
# lib/security.sh
sanitize_input() {
    local input=$1
    local type=${2:-"general"}
    
    case $type in
        "port")
            # 只允许数字
            echo "$input" | grep -E '^[0-9]+$' || return 1
            ;;
        "domain")
            # 域名格式验证
            echo "$input" | grep -E '^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$' || return 1
            ;;
        "uuid")
            # UUID格式验证
            echo "$input" | grep -E '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' || return 1
            ;;
        "path")
            # 路径安全检查
            [[ "$input" =~ \.\. ]] && return 1
            [[ "$input" =~ ^/ ]] || return 1
            echo "$input"
            ;;
        *)
            # 通用清理：移除特殊字符
            echo "$input" | sed 's/[;&|`$(){}\[\]<>]//g'
            ;;
    esac
}

validate_permissions() {
    local file_path=$1
    local expected_owner=$2
    local expected_perms=$3
    
    local actual_owner=$(stat -c '%U' "$file_path" 2>/dev/null)
    local actual_perms=$(stat -c '%a' "$file_path" 2>/dev/null)
    
    [[ "$actual_owner" == "$expected_owner" ]] || {
        log_error "文件所有者不匹配: $file_path (期望: $expected_owner, 实际: $actual_owner)"
        return 1
    }
    
    [[ "$actual_perms" == "$expected_perms" ]] || {
        log_error "文件权限不匹配: $file_path (期望: $expected_perms, 实际: $actual_perms)"
        return 1
    }
    
    return 0
}
```

## 6. 监控与诊断

### 6.1 健康检查系统
```bash
# lib/health_check.sh
perform_health_check() {
    local check_type=${1:-"full"}
    local issues=()
    
    log_info "开始系统健康检查..."
    
    # 检查配置文件
    if ! check_config_integrity; then
        issues+=("配置文件完整性检查失败")
    fi
    
    # 检查服务状态
    if ! check_service_status; then
        issues+=("服务状态异常")
    fi
    
    # 检查端口监听
    if ! check_port_listening; then
        issues+=("端口监听异常")
    fi
    
    # 检查证书有效性
    if ! check_certificate_validity; then
        issues+=("证书有效性检查失败")
    fi
    
    # 输出结果
    if [[ ${#issues[@]} -eq 0 ]]; then
        log_info "✓ 系统健康检查通过"
        return 0
    else
        log_error "✗ 发现 ${#issues[@]} 个问题:"
        for issue in "${issues[@]}"; do
            log_error "  - $issue"
        done
        return 1
    fi
}

check_config_integrity() {
    local config_file="/etc/singbox/config.json"
    
    # 文件存在性检查
    [[ -f "$config_file" ]] || {
        log_error "配置文件不存在: $config_file"
        return 1
    }
    
    # JSON格式检查
    if ! jq empty "$config_file" 2>/dev/null; then
        log_error "配置文件JSON格式无效"
        return 1
    fi
    
    # 必要字段检查
    local required_fields=("inbounds" "outbounds")
    for field in "${required_fields[@]}"; do
        if ! jq -e ".$field" "$config_file" >/dev/null 2>&1; then
            log_error "配置文件缺少必要字段: $field"
            return 1
        fi
    done
    
    return 0
}
```

## 7. 实施计划

### 7.1 优先级排序
1. **高优先级** (立即实施)
   - 错误处理标准化
   - 参数验证增强
   - 日志系统完善
   - 配置记忆功能修复

2. **中优先级** (1-2周内)
   - 配置管理中心化
   - 性能优化
   - 安全性增强
   - 健康检查系统

3. **低优先级** (长期规划)
   - 自动化测试框架
   - 配置模板系统
   - 版本管理改进

### 7.2 实施步骤
1. **第一阶段**: 核心功能稳定性
   - 修复配置记忆问题
   - 完善错误处理
   - 增强日志记录

2. **第二阶段**: 架构优化
   - 重构配置管理
   - 优化性能瓶颈
   - 增强安全性

3. **第三阶段**: 可维护性提升
   - 建立测试框架
   - 完善监控系统
   - 优化用户体验

## 8. 总结

通过以上改进建议，我们可以显著提升脚本的代码质量和可维护性：

- **稳定性**: 通过标准化错误处理和参数验证，减少运行时错误
- **性能**: 通过缓存机制和并发处理，提升执行效率
- **安全性**: 通过输入验证和权限检查，增强系统安全
- **可维护性**: 通过模块化设计和测试框架，降低维护成本
- **可扩展性**: 通过模板系统和配置中心，便于功能扩展

这些改进将为脚本的长期发展奠定坚实基础，确保在功能不断增加的同时保持代码质量。